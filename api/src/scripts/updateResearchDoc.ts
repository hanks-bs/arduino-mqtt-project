/*
 Updates docs/ASPEKT_BADAWCZY.md AUTO-RESULTS section with latest benchmark summary.
 Looks for newest folder in api/benchmarks/, reads summary.json, generates a table and notes.
*/
import fs from 'fs-extra';
import path from 'node:path';

async function main() {
  const repoRoot = path.resolve(__dirname, '../../..');
  const benchesDir = path.join(repoRoot, 'api', 'benchmarks');
  const researchPath = path.join(repoRoot, 'docs', 'ASPEKT_BADAWCZY.md');

  const exists = await fs.pathExists(benchesDir);
  if (!exists) throw new Error(`Brak folderu benchmarków: ${benchesDir}`);

  const entries = (await fs.readdir(benchesDir)).filter(
    n => !n.startsWith('.'),
  );
  if (entries.length === 0) throw new Error('Brak wyników w api/benchmarks');
  const sorted = entries.sort((a, b) => (a > b ? -1 : 1));
  const latest = sorted[0];
  const latestDir = path.join(benchesDir, latest);
  const summaryPath = path.join(latestDir, 'summary.json');
  const csvPath = path.join(latestDir, 'sessions.csv');
  const readmePath = path.join(latestDir, 'README.md');

  const summary = await fs.readJSON(summaryPath);
  const items = (summary.summaries || []) as Array<any>;
  const runCfg = summary.runConfig as
    | undefined
    | {
        modes: string[];
        hzSet: number[];
        loadSet: number[];
        durationSec: number;
        monitorTickMs: number;
        clientsHttp: number;
        clientsWs: number;
        wsPayload: number;
        httpPayload: number;
      };
  const byLoad: Array<any> = (summary.byLoad || []) as Array<any>;

  // Build table with two WS and two HTTP rows (as generated by measurementRunner)
  const header = `| Label | Mode | Rate [/s] | Bytes/s | ~Payload [B] | Jitter [ms] | Świeżość [ms] | ELU p99 [ms] | Rate OK | Payload OK |
|---|---:|---:|---:|---:|---:|---:|---:|:--:|:--:|`;
  const rows = items
    .map(s => {
      const rateOk = s.rateOk === undefined ? '—' : s.rateOk ? '✅' : '❌';
      const payloadOk =
        s.payloadOk === undefined ? '—' : s.payloadOk ? '✅' : '❌';
      return `| ${s.label} | ${s.mode} | ${s.avgRate.toFixed(2)} | ${s.avgBytesRate.toFixed(0)} | ${s.avgPayload.toFixed(0)} | ${s.avgJitterMs.toFixed(1)} | ${s.avgFreshnessMs.toFixed(0)} | ${s.avgDelayP99.toFixed(1)} | ${rateOk} | ${payloadOk} |`;
    })
    .join('\n');

  const notes = items
    .map(s => `- ${s.label}: ${s.checks?.join('; ') || ''}`)
    .join('\n');

  const block = `Ostatni run: ${latest}

Pliki: [sessions.csv](../api/benchmarks/${latest}/sessions.csv), [summary.json](../api/benchmarks/${latest}/summary.json), [README](../api/benchmarks/${latest}/README.md)

${header}
${rows}

Wnioski:
${notes}
${renderRunConfig(runCfg)}

${renderByLoadSection(byLoad)}
`;

  const md = await fs.readFile(researchPath, 'utf8');
  const start = '<!-- AUTO-RESULTS:BEGIN -->';
  const end = '<!-- AUTO-RESULTS:END -->';
  const sIdx = md.indexOf(start);
  const eIdx = md.indexOf(end);
  if (sIdx === -1 || eIdx === -1) {
    throw new Error(
      'Nie znaleziono znaczników AUTO-RESULTS w ASPEKT_BADAWCZY.md',
    );
  }
  const before = md.slice(0, sIdx + start.length);
  const after = md.slice(eIdx);
  const updated = `${before}\n\n${block}\n${after}`;
  await fs.writeFile(researchPath, updated, 'utf8');
  console.log('Zaktualizowano docs/ASPEKT_BADAWCZY.md wynikami z', latest);
}

main().catch(err => {
  console.error('Błąd aktualizacji dokumentu badawczego:', err.message);
  process.exit(1);
});

function renderRunConfig(cfg?: any): string {
  if (!cfg) return '';
  const modes = Array.isArray(cfg.modes)
    ? cfg.modes.join(', ')
    : String(cfg.modes ?? '—');
  const hz = Array.isArray(cfg.hzSet)
    ? cfg.hzSet.join(', ')
    : String(cfg.hzSet ?? '—');
  const load = Array.isArray(cfg.loadSet)
    ? cfg.loadSet.join(', ')
    : String(cfg.loadSet ?? '—');
  return `

Parametry przyjęte w ostatnim runie:
- Metody: ${modes}
- Częstotliwości [Hz]: ${hz}
- Obciążenia CPU [%]: ${load}
- Czas sesji [s]: ${cfg.durationSec}
- MONITOR_TICK_MS: ${cfg.monitorTickMs}
- Payloady: WS=${cfg.wsPayload}B, HTTP=${cfg.httpPayload}B
- Klienci: clientsHttp=${cfg.clientsHttp}, clientsWs=${cfg.clientsWs}
`;
}

function renderByLoadSection(byLoad: Array<any>): string {
  if (!byLoad || byLoad.length === 0) return '';
  const ws = byLoad.filter(r => r.mode === 'ws');
  const http = byLoad.filter(r => r.mode === 'polling');
  const header = `| Obciążenie | Rate [/s] | Bytes/s | ~Payload [B] | Jitter [ms] | ELU p99 [ms] | CPU [%] | RSS [MB] |
|---:|---:|---:|---:|---:|---:|---:|---:|`;
  const mk = (rows: any[]) =>
    rows
      .sort((a, b) => (a.loadCpuPct ?? 0) - (b.loadCpuPct ?? 0))
      .map(
        r =>
          `| ${r.loadCpuPct ?? 0}% | ${nf(r.avgRate, 2)} | ${nf(r.avgBytesRate, 0)} | ${nf(r.avgPayload, 0)} | ${nf(r.avgJitterMs, 1)} | ${nf(r.avgDelayP99, 1)} | ${nf(r.avgCpu, 1)} | ${nf(r.avgRss, 1)} |`,
      )
      .join('\n');
  const wsTbl = ws.length
    ? `### Porównanie wg obciążenia — WebSocket\n\n${header}\n${mk(ws)}\n`
    : '';
  const httpTbl = http.length
    ? `### Porównanie wg obciążenia — HTTP polling\n\n${header}\n${mk(http)}\n`
    : '';
  return `\n\n## Zestawienie wg obciążenia (agregaty)\n\n${wsTbl}${httpTbl}`;
}

function nf(n: any, frac = 1): string {
  const x = Number(n);
  return Number.isFinite(x) ? x.toFixed(frac) : '—';
}
